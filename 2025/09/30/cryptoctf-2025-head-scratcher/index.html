<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CryptoCTF 2025 head scratcher 分类 团队解题 writeup | 春勃</title><meta name="author" content="ZM-J"><meta name="copyright" content="ZM-J"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="title: CryptoCTF 2025 head scratcher 分类 团队解题 writeupcategory:  CTF Cryptomathjax: true   这次 head scratcher 分类由于人力短缺，以及水平不得行，所以全军覆没了。虽然爆零了，但是至少 1997 的各位都战斗到最后，搏至无憾了。反观某个叛徒，在他人唆使之下叛逃 1997，利令智昏，得不偿失！  从">
<meta property="og:type" content="article">
<meta property="og:title" content="CryptoCTF 2025 head scratcher 分类 团队解题 writeup">
<meta property="og:url" content="https://zm-j.github.io/2025/09/30/cryptoctf-2025-head-scratcher/index.html">
<meta property="og:site_name" content="春勃">
<meta property="og:description" content="title: CryptoCTF 2025 head scratcher 分类 团队解题 writeupcategory:  CTF Cryptomathjax: true   这次 head scratcher 分类由于人力短缺，以及水平不得行，所以全军覆没了。虽然爆零了，但是至少 1997 的各位都战斗到最后，搏至无憾了。反观某个叛徒，在他人唆使之下叛逃 1997，利令智昏，得不偿失！  从">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://zm-j.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2025-09-30T10:14:00.000Z">
<meta property="article:modified_time" content="2025-09-30T10:14:25.550Z">
<meta property="article:author" content="ZM-J">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zm-j.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zm-j.github.io/2025/09/30/cryptoctf-2025-head-scratcher/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CryptoCTF 2025 head scratcher 分类 团队解题 writeup',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-09-30 18:14:25'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">7</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="春勃"><span class="site-name">春勃</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CryptoCTF 2025 head scratcher 分类 团队解题 writeup</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-09-30T10:14:00.000Z" title="Created 2025-09-30 18:14:00">2025-09-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-09-30T10:14:25.550Z" title="Updated 2025-09-30 18:14:25">2025-09-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CTF/">CTF</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CTF/Crypto/">Crypto</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CryptoCTF 2025 head scratcher 分类 团队解题 writeup"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><hr>
<p>title: CryptoCTF 2025 head scratcher 分类 团队解题 writeup<br>category:</p>
<ul>
<li>CTF</li>
<li>Crypto<br>mathjax: true</li>
</ul>
<hr>
<p>这次 head scratcher 分类由于人力短缺，以及水平不得行，所以全军覆没了。虽然爆零了，但是至少 1997 的各位都战斗到最后，搏至无憾了。<strong>反观某个叛徒，在他人唆使之下叛逃 1997，利令智昏，得不偿失！</strong></p>
<blockquote>
<p>从 discord 到 QQ 的 1997 交流群，一副阻挡叛徒的铁幕已经降落下来</p>
</blockquote>
<h2 id="Alice-Sig-Slip-x"><a href="#Alice-Sig-Slip-x" class="headerlink" title="Alice Sig Slip (x)"></a>Alice Sig Slip (x)</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>题目基于 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/EdDSA">EdDSA</a>，使用的曲线为 ED25519，用 RFC8032 的参数（生成元 $G$ 固定）生成一个密钥 $(x, P)$ 满足 $P = x G$，然后有 5 组消息 $m_i, i = 0, 1, 2, 3, 4$，然后对这个消息签名得到 5 组数据 $(P, r_i, s_i, m_i)$ 其中 $P = x G$ 为公钥。这些数据可以排列成一个矩阵：</p>
<script type="math/tex; mode=display">\begin{bmatrix}P_0 & r_0 & s_0 & m_0 \\
P & r_1 & s_1 & m_1 \\
P & r_2 & s_2 & m_2 \\
P & r_3 & s_3 & m_3 \\
P & r_4 & s_4 & m_4 \\ \end{bmatrix}</script><p>然后题目会涂掉一些数，变成下面这样：</p>
<script type="math/tex; mode=display">\begin{bmatrix}P & r_0 & s_0 & m_0 \\
? & r_1 & s_1 & m_1 \\
? & ? & s_2 & m_2 \\
? & ? & ? & m_3 \\
? & ? & ? & ? \\ \end{bmatrix}</script><p>我们需要把 $?$ 中的数字补上，让这几组数据都能通过 EdDSA 的签名验证。如果能做到的话，则得到 flag。</p>
<h3 id="我的解答-x"><a href="#我的解答-x" class="headerlink" title="我的解答 (x)"></a>我的解答 (x)</h3><p>对于上面矩阵的最后一行：直接填 $(P, r_0, s_0, m_0)$ 即可；</p>
<p>对于上面矩阵的倒数第二行：直接生成一组 EdDSA 公钥 $P’ = x’ G$ 然后用其签名，得到 $(r’, s’)$ 即可；</p>
<p>对于上面矩阵的倒数第四行：直接复制 $P$ 即可；</p>
<p>所以难点还是在第三行：怎么提供 $P’, r’$，使得验签式满足</p>
<p>先走一下代码审计，看看能不能在他的实现里面找到一些猫腻。</p>
<p>在比赛时，我有发现一点：在 <code>eddsa.import_public_key(encoded=public_key)</code> 中，会根据不同的密钥长度判断不同的加密算法：，具体可见 <code>Crypto/Signature/eddsa.py L41</code>，具有 ed25519 和 ed448 两种形式。我有在想能不能通过输入过长的密钥让检验走 ed448，从而利用到一些什么东西但是好像并不能利用到什么东西。</p>
<p>然后就是去找验签的过程，在 <code>Crypto/Signature/eddsa.py L209</code>：</p>
<ul>
<li>同样会先根据密钥的长度（实例化的时候已经做掉了）来判断走 ed25519 的验签，走到 <code>Crypto/Signature/eddsa.py L244</code> </li>
<li>前面那个 <code>dom2</code> 应该会取空字符串</li>
<li>计算 $k = \mathrm{SHA512}(dom2 || r || P || msg) \bmod n$</li>
<li>然后检验签名是否成立</li>
</ul>
<p>等于说这里的 $r$ 和 $P$ 是会共同影响到 $k$ 的计算，但是后面验签的时候验证：</p>
<script type="math/tex; mode=display">8sG = 8(R + k P)</script><p>是否成立</p>
<p>也是就是说，由于有 SHA512 哈希的存在，并不知道如何通过 $R$ 和 $P$ 来</p>
<h3 id="赛后复盘"><a href="#赛后复盘" class="headerlink" title="赛后复盘"></a>赛后复盘</h3><p>其实这道题目没做出来主要是对 EdDSA 本身的运作机制不是很了解，甚至说完全想当然，很多细节上的东西全凭主观臆断了。当然，这也和 1997 EdDSA 专家：托林在比赛的时间段没啥空有关，但是不可能把宝全部押在一个人身上。<strong>但是呢，对于临阵叛逃、负输出的行为，1997 是零容忍的。</strong></p>
<p>实际上，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/EdDSA">维基百科对 EdDSA 的阐述</a> 就很详细了：</p>
<ul>
<li>EdDSA 是利用 $\mathbb{F}_{q}$ 上的椭圆曲线 $E$，其 $\mathbb{F}_{q}$ 关系点群 $E(\mathbb {F} _{q})$ 的阶数为 $#E(\mathbb {F} _{q})=2^{c}\ell$，其中 $\ell$ 是一个大素数且 $2^{c}$ 被称为辅因子</li>
<li>基点 $B\in E(\mathbb {F} _{q})$ 的阶数为 $\ell$</li>
</ul>
<p>也就是说，和 DSA 一样，EdDSA 对点的操作是在一个子群中进行的；特别地，在 ed25519 中，$c=3$，也就是说 <strong>有个 8 倍的差距</strong>！虽然无论在题目代码还是在 EdDSA 库的工程实现中，都有对无穷远点的拒绝判断，但是没有拒绝其他点的判断！这个是我请教了 <a target="_blank" rel="noopener" href="https://blog.maple3142.net/">maple3142</a> 之后才发现的，由衷感谢！</p>
<p>虽然如此，但是实际上 EdDSA 的具体实现中会把 order 给写死成基点 $B$ 的阶数 $\ell$，具体实现可以找到 <code>Crypto/PublicKey/ECC.py L112</code>，直接利用查表的方式，根据 <code>curve_name</code> 找到一组参数；特别地，ed25519 的参数存放于 <code>Crypto/PublicKey/_edwards.py</code> 中，可以看到参数中的 order 是奇数，因为这个 order 是 $B$ 的 order。在比赛的时候，我有尝试去打印出这个 order，然后发现它是个奇素数，就没有往下深挖了，还是因为缺少对 EdDSA 的一个 big picture 才导致当时做的时候比较乱。</p>
<p>回到验签过程中：</p>
<ul>
<li>首先我们提供 $P’$ 和 $r’$</li>
<li>然后计算 $k’$</li>
<li>然后计算是否 $8sG = 8(R’ + k’ P’)$ 成立</li>
</ul>
<p>这个式子的左边是个定值，右边可以取：</p>
<ul>
<li>$R’ = s G$</li>
<li>$8 P’ = O$<br>即可满足，这样我们既把不可控的 $k’$ 给摆脱了，又可以避免输入无穷远点。</li>
</ul>
<p>然后还有一个实现上的细节（或许也不能算是细节？），就是题目数据中点 $P$ 的导出，并不是仅导出 $x$ 坐标或者 $y$ 坐标的值的。实际上，在 EdDSA 的实现中，是有“正点”和“负点”的区分的，具体可以参考 <code>Crypto/PublicKey/ECC.py L288</code>：虽然在模素数 $q$ 中，点的坐标值都是正的，但是由于 $q$ 是奇数，所以如果点 $P(x, y)$ 中的 $x$ 是奇数，那么点 $-P(-x, y)$ 中的 $-x$ 实际上就是 $p-x$，是偶数。把点导出的结果是同时包含了 $y$ 的值和 $x$ 的奇偶性的，这就给出了点的唯一性。</p>
<p>然后这个 torsion point 可能要自己去找，或者直接搜，这里利用 ed25519 和 Curve25519 （后者是 Montgomery Curve）双有理等价的性质，直接在 Curve25519 上找 torsion point：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed</span><br><span class="line">K = GF(p)</span><br><span class="line"></span><br><span class="line">E = EllipticCurve(GF(p), [0,486662,0,1,0])</span><br><span class="line"></span><br><span class="line">print(factor(E.order()))</span><br></pre></td></tr></table></figure>
<p>可以看到结果是 $2^3 \cdot \ell$，所以直接利用这个求就行了。求出来之后还需要走一下格式转化，代码在 <code>Crypto/PublicKey/ECC L431</code> → <code>Crypto/PublicKey/ECC L288</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">p = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed</span><br><span class="line">K = GF(p)</span><br><span class="line"></span><br><span class="line">E = EllipticCurve(GF(p), [0,486662,0,1,0])</span><br><span class="line"></span><br><span class="line">n = E.order()</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    P = E.random_point()</span><br><span class="line">    Q = (n // 8) * P</span><br><span class="line">    if Q != E(0):</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">print(f&#x27;&#123;Q.order() = &#125;&#x27;)</span><br><span class="line"></span><br><span class="line">u, v = Q.xy()</span><br><span class="line">x = u/v * K(-486664).sqrt()</span><br><span class="line">y = (u-1)/(u+1)</span><br><span class="line"></span><br><span class="line">print(f&#x27;&#123;x = &#125;&#x27;)</span><br><span class="line">print(f&#x27;&#123;y = &#125;&#x27;)</span><br><span class="line"></span><br><span class="line">LHS = -x^2 + y^2</span><br><span class="line">RHS = 1 - K(121665 / 121666) * x^2 * y^2</span><br><span class="line">print(f&#x27;&#123;LHS - RHS = &#125;&#x27;)</span><br><span class="line"></span><br><span class="line">x, y = map(int, (x, y))</span><br><span class="line">result = bytearray(y.to_bytes(32, byteorder=&#x27;little&#x27;))</span><br><span class="line">result[31] = ((x &amp; 1) &lt;&lt; 7) | result[31]</span><br><span class="line">res = bytes(result)</span><br><span class="line"></span><br><span class="line">print(f&#x27;&#123;res = &#125;&#x27;)</span><br></pre></td></tr></table></figure>
<p>在写代码的时候，我发现了一个细节上的东西：<code>pycryptodome</code> 初始化 ECC 密钥主要利用了 <code>construct</code> 方法，该方法会用 <code>EccKey</code> 类的实例化产生一个对象（有点像设计模式里面的工厂模式）。在 <code>EccKey</code> 对象的实例化中，有对 ed25519 的参数处理（可参考 <code>Crypto/PublicKey/ECC.py L128</code>）：</p>
<ul>
<li><code>self._d</code> 必须是 None </li>
<li><code>self._seed</code> 长度必须是 32</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> self._curve.<span class="built_in">id</span> == _CurveID.ED25519:</span><br><span class="line">    <span class="keyword">if</span> self._d <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Parameter d can only be used with NIST P curves&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(self._seed) != <span class="number">32</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Parameter seed must be 32 bytes long for Ed25519&quot;</span>)</span><br><span class="line">    seed_hash = SHA512.new(self._seed).digest()   <span class="comment"># h</span></span><br><span class="line">    self._prefix = seed_hash[<span class="number">32</span>:]</span><br><span class="line">    tmp = <span class="built_in">bytearray</span>(seed_hash[:<span class="number">32</span>])</span><br><span class="line">    tmp[<span class="number">0</span>] &amp;= <span class="number">0xF8</span></span><br><span class="line">    tmp[<span class="number">31</span>] = (tmp[<span class="number">31</span>] &amp; <span class="number">0x7F</span>) | <span class="number">0x40</span></span><br><span class="line">    self._d = Integer.from_bytes(tmp, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>也就是说，这样的设定让我们 <strong>无法通过直接指定私钥的值的方式来初始化一个 ed25519 密钥</strong>。这里我们需要事先对 <code>pycryptodome</code> 的实现稍加改动，使得可以直接指定私钥的值，来初始化一个 ed25519 密钥：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> self._curve.<span class="built_in">id</span> == _CurveID.ED25519:            </span><br><span class="line">    <span class="keyword">if</span> self._d <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        self._d = Integer(self._d)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self._seed) != <span class="number">32</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;Parameter seed must be 32 bytes long for Ed25519&quot;</span>)</span><br><span class="line">        seed_hash = SHA512.new(self._seed).digest()   <span class="comment"># h</span></span><br><span class="line">        self._prefix = seed_hash[<span class="number">32</span>:]</span><br><span class="line">        tmp = <span class="built_in">bytearray</span>(seed_hash[:<span class="number">32</span>])</span><br><span class="line">        tmp[<span class="number">0</span>] &amp;= <span class="number">0xF8</span></span><br><span class="line">        tmp[<span class="number">31</span>] = (tmp[<span class="number">31</span>] &amp; <span class="number">0x7F</span>) | <span class="number">0x40</span></span><br><span class="line">        self._d = Integer.from_bytes(tmp, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>然后解题代码如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Math.Numbers <span class="keyword">import</span> Integer</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> ECC</span><br><span class="line"><span class="keyword">from</span> Crypto.Signature <span class="keyword">import</span> eddsa</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gao</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.conn = process([<span class="string">&#x27;python3&#x27;</span>, <span class="string">&#x27;another.py&#x27;</span>])</span><br><span class="line">        self.messages = [</span><br><span class="line">            <span class="string">b&quot;Alice cracks codes in her sleep.&quot;</span>,</span><br><span class="line">            <span class="string">b&quot;Alice never leaves a cipher unsolved.&quot;</span>,</span><br><span class="line">            <span class="string">b&quot;No flag for those who give up too soon, says Alice.&quot;</span>,</span><br><span class="line">            <span class="string">b&quot;Alice never gives up; that&#x27;s why she always gets the flag.&quot;</span>,</span><br><span class="line">            <span class="string">b&quot;Alice loves solving ciphers, especially when they&#x27;re tricky.&quot;</span>,</span><br><span class="line">        ]</span><br><span class="line">        self.ans = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recv_known</span>(<span class="params">self</span>):</span><br><span class="line">        self.conn.sendlineafter(<span class="string">&#x27;[Q]uit\n&#x27;</span>, <span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            c = self.conn.recvline().strip().decode()</span><br><span class="line">            c = c.split(<span class="string">&#x27; : &#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">            a = [x.strip() <span class="keyword">for</span> x <span class="keyword">in</span> c.split(<span class="string">&#x27;,&#x27;</span>)]</span><br><span class="line">            self.ans.append(a)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">complete_other</span>(<span class="params">self</span>):</span><br><span class="line">        self.ans[<span class="number">1</span>][<span class="number">0</span>] = self.ans[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            self.ans[<span class="number">4</span>][i] = self.ans[<span class="number">0</span>][i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gao_3</span>(<span class="params">self</span>):        </span><br><span class="line">        some_key = ECC.generate(curve=<span class="string">&#x27;ed25519&#x27;</span>)</span><br><span class="line">        signer = eddsa.new(some_key, <span class="string">&#x27;rfc8032&#x27;</span>)</span><br><span class="line">        signature = signer.sign(self.messages[<span class="number">3</span>])</span><br><span class="line">        </span><br><span class="line">        self.ans[<span class="number">3</span>][<span class="number">0</span>] = some_key.public_key().export_key(<span class="built_in">format</span>=<span class="string">&#x27;raw&#x27;</span>).<span class="built_in">hex</span>()</span><br><span class="line">        self.ans[<span class="number">3</span>][<span class="number">1</span>] = signature[:<span class="number">32</span>].<span class="built_in">hex</span>()</span><br><span class="line">        self.ans[<span class="number">3</span>][<span class="number">2</span>] = signature[<span class="number">32</span>:].<span class="built_in">hex</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gao_2</span>(<span class="params">self</span>):</span><br><span class="line">        wtf = <span class="string">b&#x27;\xc7\x17jp=M\xd8O\xba&lt;\x0bv\r\x10g\x0f* S\xfa,9\xcc\xc6N\xc7\xfdw\x92\xac\x03\xfa&#x27;</span></span><br><span class="line">        wtf = <span class="string">b&#x27;\xc7\x17jp=M\xd8O\xba&lt;\x0bv\r\x10g\x0f* S\xfa,9\xcc\xc6N\xc7\xfdw\x92\xac\x03z&#x27;</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        s = Integer.from_bytes(<span class="built_in">bytes</span>.fromhex(self.ans[<span class="number">2</span>][<span class="number">2</span>]), <span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">        <span class="comment"># ed25519 = ECC._curves [&#x27;ed25519&#x27;]</span></span><br><span class="line">        some_key = ECC.construct(curve=<span class="string">&#x27;ed25519&#x27;</span>, d=s)</span><br><span class="line">        r = some_key.public_key().export_key(<span class="built_in">format</span>=<span class="string">&#x27;raw&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        self.ans[<span class="number">2</span>][<span class="number">0</span>] = wtf.<span class="built_in">hex</span>()</span><br><span class="line">        self.ans[<span class="number">2</span>][<span class="number">1</span>] = r.<span class="built_in">hex</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">submit_ans</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            self.conn.sendlineafter(<span class="string">&#x27;[Q]uit\n&#x27;</span>, <span class="string">&#x27;U&#x27;</span>)</span><br><span class="line">            m = <span class="string">f&#x27;<span class="subst">&#123;i&#125;</span>,&#x27;</span> + <span class="string">&#x27;,&#x27;</span>.join(self.ans[i])</span><br><span class="line">            self.conn.sendlineafter(<span class="string">&#x27;msg:&#x27;</span>, m)</span><br><span class="line">        self.conn.sendlineafter(<span class="string">&#x27;[Q]uit\n&#x27;</span>, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gao</span>(<span class="params">self</span>):</span><br><span class="line">        self.recv_known()</span><br><span class="line">        self.complete_other()</span><br><span class="line">        self.gao_3()</span><br><span class="line">        self.gao_2()</span><br><span class="line">        self.submit_ans()</span><br><span class="line">        self.conn.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    g = Gao()</span><br><span class="line">    g.gao()</span><br></pre></td></tr></table></figure>
<h2 id="Hoshi-x"><a href="#Hoshi-x" class="headerlink" title="Hoshi (x)"></a>Hoshi (x)</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>$p$ 为一个未知 256 比特素数，在 $\mathbb{Z}/p^{12}\mathbb{Z}$ 中定义椭圆曲线 $E: y^2 = x^3 + a x + b$，给定 5 个点 $P_1(x_1, y_1), P_2(x_2, y_2), \ldots, P_5(x_5, y_5)$ 以及其相应倍点 $d_1 P_1, d_2 P_2, \ldots, d_5 P_5$，保证 $1 \le d_i \le p^{11}, i = 1, 2, \ldots, 5$。需要求出这些 $d_i$，全部求出就能得到 flag</p>
<h3 id="我的解答-x-1"><a href="#我的解答-x-1" class="headerlink" title="我的解答 (x)"></a>我的解答 (x)</h3><p>比赛的时候，我和沛公都想到论文 <a target="_blank" rel="noopener" href="https://arxiv.org/pdf/2010.15543">The group structure of elliptic curves over Z/NZ</a>，该论文解析了椭圆曲线论文在整数模 $N$ 的环上的点群结构。主要就是在非奇异情形（即 $q:=|E(\mathbb{F}_p)| \ne p$）下，那么</p>
<script type="math/tex; mode=display">E(\mathbb{Z}/p^{e}\mathbb{Z}) \cong E(\mathbb{Z}/p^{e}\mathbb{Z}) \oplus \mathbb{Z}/p^{e-1}\mathbb{Z}</script><p>相当于可以把 $E(\mathbb{Z}/p^{e}\mathbb{Z})$ 分为两部分</p>
<ol>
<li>投射到 $\mathbb{F}_p$ 的部分 $E(\mathbb{F}_p)$</li>
<li>无穷远点部分 $E^\infty$</li>
</ol>
<p>然后就有一个结论：这个 $E^\infty$ 是一个 $p^{e}$ torsor，就是一个循环群。</p>
<p>然后这里是模 $p^{12}$，但是 $d_i$ 不大于 $p^{11}$，所以应该就是这篇了。</p>
<p>首先是解参数，这个可以参考 <a href="https://zm-j.github.io/2025/07/25/cryptoctf-2025-getting-there-2/#Sobata">Sobata</a> 相关的内容解出来，不是本题的主要难点</p>
<p>然后就是分别去解离散对数。继续看论文：</p>
<ul>
<li>论文中第 5 章给出了针对 $|E(\mathbb{Z}/p^{e}\mathbb{Z})| = p^{e}$ 时的同构攻击，这就需要赌 $q = |E(\mathbb{F}_p)| = p$，这个肯定概率太小了，不予考虑；</li>
<li>论文中命题 4 也给出了当 $1 \le e \le 5$，且 $q \neq p$ 的时候，有一个良定义的群同态 $\Phi$</li>
<li>论文中命题 2 给出了无穷远点的结构，说是 <strong>存在</strong> 一个 $f(X)$ 可以在模 $p^{10}$ 中考虑，但是好像也没给出 $f$ 的具体形式</li>
</ul>
<p>然后就不知道怎么弄了</p>
<h3 id="赛后复盘-1"><a href="#赛后复盘-1" class="headerlink" title="赛后复盘"></a>赛后复盘</h3><p>之前在 sagemath 中，可以通过 p-adic number 的形式实现对无穷远点的兼容</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">set_random_seed(<span class="number">4396</span>)</span><br><span class="line"></span><br><span class="line">nbit = <span class="number">256</span></span><br><span class="line">l, p, n = <span class="number">12</span>, getPrime(nbit), <span class="number">5</span></span><br><span class="line">PTS,a,b = gen_curve(p, l, n)</span><br><span class="line">SCV = [randint(<span class="number">1</span>, p ^ (l - <span class="number">1</span>)) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">EPT = [SCV[_] * PTS[_] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">E = EllipticCurve(Zmod(p ^ l), [a, b])</span><br><span class="line">E0 = EllipticCurve(Zmod(p), [a, b])</span><br><span class="line">n0 = E0.order()</span><br><span class="line">EQp = EllipticCurve(Qp(p, prec=<span class="number">12</span>), [a, b])</span><br><span class="line"></span><br><span class="line">P0 = PTS[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(P0)</span><br><span class="line">PQp = P0.change_ring(Qp(p, prec=<span class="number">12</span>))</span><br><span class="line"><span class="built_in">print</span>(PQp)</span><br><span class="line"></span><br><span class="line">P0y = P0[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;ZZ(P0y).digits(p) = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;n0 * P0 = &#125;</span>&#x27;</span>) <span class="comment"># OK in 10.6</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;n0 * PQp = &#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>打印出来，可以观察到这里 PQp 实际上就是 P0 坐标的 $p$ 进制表示（因为是模 $p^l$ 的，所以已经没有 <code>P.xy()</code> 方法），然后后面也是能直接打印出 <code>n0 * P0</code> 的值的，貌似在 SageMath 10.6 中可以直接在 <code>mod p^l</code> 上运算了？我好像记得之前版本是不支持这玩意儿的，以前是直接算到无穷远点上貌似会出问题。然后就出问题：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">K0 = n0 * P0</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;K0 = &#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># K1 = 2 * K0</span></span><br><span class="line">K1 = (<span class="number">2</span> * n0) * P0</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;K1 = &#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>直接运行 <code>K1 = 2 * K0</code> 是会报错的：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  File <span class="string">&quot;/home/xxx/miniconda3/envs/sage/lib/python3.12/site-packages/sage/schemes/elliptic_curves/ell_point.py&quot;</span>, line <span class="number">340</span>, <span class="keyword">in</span> _add_</span><br><span class="line">    pt = CRT_vectors([pt, [x1.lift(), y1.lift(), z1.lift()]], [mod, mod_1st])</span><br><span class="line">         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">  File <span class="string">&quot;/home/xxx/miniconda3/envs/sage/lib/python3.12/site-packages/sage/arith/misc.py&quot;</span>, line <span class="number">3718</span>, <span class="keyword">in</span> CRT_vectors</span><br><span class="line">    a = CRT_basis(moduli)</span><br><span class="line">        ^^^^^^^^^^^^^^^^^</span><br><span class="line">  File <span class="string">&quot;/home/xxx/miniconda3/envs/sage/lib/python3.12/site-packages/sage/arith/misc.py&quot;</span>, line <span class="number">3683</span>, <span class="keyword">in</span> CRT_basis</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&#x27;moduli must be coprime&#x27;</span>)</span><br><span class="line">ValueError: moduli must be coprime</span><br></pre></td></tr></table></figure>
<p>所以我们要么只能写成 <code>K1 = (2 * n0) * P0</code>，要么用 p-adic number 表示数：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">KQp = n0 * PQp</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;KQp = &#125;</span>&#x27;</span>)</span><br><span class="line">KKQp = <span class="number">2</span> * KQp</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;KKQp = &#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>于是我们就可以利用论文中命题 4 的映射，去解决 $e \le 5$ 的情形，也就是得出 $d \bmod p^{4}$ 的值：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">F_ = Zmod(p^(l-<span class="number">1</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_l</span>(<span class="params">P</span>):</span><br><span class="line">    K = n0 * P</span><br><span class="line">    <span class="keyword">return</span> F_(ZZ(K[<span class="number">0</span>]) / p) / F_(K[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">l0 = get_l(P0)</span><br><span class="line"></span><br><span class="line">d = <span class="number">2</span></span><br><span class="line">P1 = d * P0</span><br><span class="line">l1 = get_l(P1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;l0 % p^<span class="number">4</span> = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;l1 % p^<span class="number">4</span> = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;d * l0 % p^<span class="number">4</span> = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;l0 % p^<span class="number">5</span> = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;l1 % p^<span class="number">5</span> = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;d * l0 % p^<span class="number">5</span> = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
<p>当然上面这个 <code>get_l</code> 也可以用 p-adic number 去做。可以看到，下面模 $p^4$ 的值是能够对上的，但是模 $p^5$ 的值对不上，我和沛公比赛的时候就是卡在了这里。赛后看到 maple 做出来了，自然去问了一下：</p>
<blockquote>
<p>把 mod p^4 的部分減掉然後進位<br>反覆做就行了</p>
</blockquote>
<p>回到题目，假设我们已经求出了 $d \bmod p^4$ 的值，写成式子就是：</p>
<script type="math/tex; mode=display">Q = d P = (d_0 + d_1 p^4) P</script><p>其中这里的 $d_0$ 是通过上述方法求出来的，$d_1$ 是需要继续去求的值。</p>
<p>因为无穷远点群是一个循环群，所以在实验的时候，直接把 $K$ 的 $x$ 坐标不是除以 $p$，而是除以 $p^5$ 就行了，可以看看下面这个例子：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_l</span>(<span class="params">P, t</span>):</span><br><span class="line">    K = n0 * P</span><br><span class="line">    F_ = Zmod(p^<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> F_(ZZ(K[<span class="number">0</span>]) / p^t) / F_(K[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">l0 = get_l(P0, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">d = <span class="number">3</span> * p^<span class="number">4</span> + <span class="number">7</span></span><br><span class="line">P1 = d * P0</span><br><span class="line">l1 = get_l(P1, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">Q1 = P1 - <span class="number">7</span> * P0</span><br><span class="line"></span><br><span class="line">l2 = get_l(Q1, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;l2 = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;<span class="number">3</span> * l0 = &#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><em>为什么要把用来测试的 $d$ 构造成这种形式？因为时代少年团的队长叫 🐎+7</em></p>
<p>就可以验证这个“把 $\bmod p^4$ 的部分减掉”的可行性。这样子我们就能迭代求解了：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dlog</span>(<span class="params">P, Q</span>):</span><br><span class="line">    <span class="comment"># Solve Q = d P</span></span><br><span class="line">    l0 = get_l(P, <span class="number">1</span>)</span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    Q_ = Q</span><br><span class="line">    d = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; l - <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;k = &#125;</span>&#x27;</span>)</span><br><span class="line">        l1 = get_l(Q_, k + <span class="number">1</span>)</span><br><span class="line">        d_ = ZZ(l1 / l0)</span><br><span class="line">        d += d_ * p^k</span><br><span class="line">        Q_ = Q - d * P</span><br><span class="line">        k += <span class="number">4</span></span><br><span class="line">    <span class="keyword">return</span> ZZ(d % p^(l-<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">d = ZZ.random_element(p ^ (l-<span class="number">1</span>))</span><br><span class="line">P1 = d * P0</span><br><span class="line">d_ = dlog(P0, P1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;d = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;d_ = &#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>当然也可以参考沛公直接用 p-adic number 的做法：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">P0 = PTS[<span class="number">0</span>]</span><br><span class="line">PQp = P0.change_ring(Qp(p, prec=<span class="number">12</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_l</span>(<span class="params">P</span>):</span><br><span class="line">    K = n0 * P</span><br><span class="line">    <span class="keyword">return</span> K[<span class="number">0</span>] / K[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">d = <span class="number">3</span> * p^<span class="number">4</span> + <span class="number">7</span></span><br><span class="line">QQp = d * PQp</span><br><span class="line"></span><br><span class="line">l0 = get_l(PQp)</span><br><span class="line">l1 = get_l(QQp)</span><br><span class="line"></span><br><span class="line">Q1 = QQp - <span class="number">7</span> * PQp</span><br><span class="line"></span><br><span class="line">l2 = get_l(Q1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;l2 = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;<span class="number">3</span> * l0 = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;<span class="number">3</span> * get_l(p^<span class="number">4</span> * PQp) = &#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>那其实上面这个是歪打正着了，其实正确的是看到原论文的命题 3，该命题直接给出了无穷远点群的结构：</p>
<blockquote>
<p>如果 $P_1(X_1 : 1 : \mathrm{f}(X_1)), P_2(X_2 : 1 : \mathrm{f}(X_2)) \in E^{\infty}$，其中 $e_1 = \mathrm{v}_p(X_1), e_2 = \mathrm{v}_p(X_2)$，这里的 $\mathrm{v}_p(x)$ 就是 $x$ 的 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/P%E9%80%B2%E8%B3%A6%E5%80%BC">$p$ 进赋值</a>，那么：<br>$P_1 + P_2 = (X_3 : 1 : \mathrm{f}(X_3))$，其中 $X_3 \equiv X_1 + X_2 \pmod{p^{5\min\{e_1, e_2\}}}$</p>
</blockquote>
<p>也就是说：</p>
<ol>
<li>对于所有 $E^{\infty}$ 内的无穷远点，都能写成 $(X : 1 : \mathrm{f}(X))$ 的形式，其中 $X$ 中必有一个因子为 $p$，所以可以保证一开始的这个 $\mathrm{v}_p(X_1)$ 和 $\mathrm{v}_p(X_2)$ 都不小于 1，也就是上面那个同余只能在模 $p^5$ 上成立；</li>
<li>利用“以点 $q P$ 为生成元构成的椭圆曲线点群，上述性质在模 $p^5$ 上成立”的特性求离散对数 $Q = d P$（实际上转化成了求 $(qQ) = d (qP)$ 这个离散对数问题)，但是因为 $X_{qP}$ 中已经包含了一个 $p$，所以离散对数只能求出 $d \bmod p^4$ 的值，此时将 $d$ 写成 $d = d_0 + p^4 d_1$，已知 $d_0$，待求 $d_1$；</li>
<li>欲求 $d_1$ 的值，需考虑 $P’ = p^4{P}$ 和 $Q’ = Q - d_0 P$ 的离散对数问题 $Q’ = d_1 P’$（实际上去求 $qQ’ = d_1 (q P’)$ 这个离散对数问题）；</li>
<li>此时我们考察以点 $q P’$ 为生成元构成的椭圆曲线点群，我们会发现因为乘了个 $p^4$，加上原来因为映射到无穷远点上会产生的那个 $p$，所以我们可以保证 $\mathrm{v}_p(P’)$ 不小于 5；</li>
<li><strong>回看命题 3，里面描述的那个同余能在 $ \bmod p^{25}$ 之内成立了</strong>。此时去掉 $X_{qP’}$ 中已经包含的 $p^{5}$，这次离散对数可以直接求出 $d_1 \bmod p^{20}$ 的值！</li>
</ol>
<p>这个发现和上面的迭代求解的区别就是，之前都是用线性的速率去迭代的，利用完命题 3 之后，可以把迭代求解离散对数问题的过程改成平方的速率。</p>
<p><em>所以如果真正把命题 3 给搞懂了之后，其实就会发现命题 4 相当于是命题 3 的一个推论了</em></p>
<p>然后就是把交互脚本给搓出来了。在应用这个方法的时候，需要注意一个小细节：题目只给了点 $Q$ 的 $x$ 坐标，也就是点 $Q$ 的可能取值也有 2 个，需要先尝试一个去算离散对数 $d’$，然后验证 $Q = d’ P$ 是否成立从而决定结果是 $d = d’$ 还是 $d = p^{l-1} - d’$：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gao</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.conn = process([<span class="string">&#x27;sage&#x27;</span>, <span class="string">&#x27;another.sage&#x27;</span>])</span><br><span class="line">        self.N = <span class="number">5</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gao_dlp_one</span>(<span class="params">self, P, Q</span>):</span><br><span class="line">        <span class="comment"># Q = d P</span></span><br><span class="line">        p, l = self.p, self.l</span><br><span class="line">        n0 = self.n0</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_l</span>(<span class="params">P</span>):</span><br><span class="line">            K = n0 * P</span><br><span class="line">            F_ = Zmod(p**<span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span> F_(ZZ(K[<span class="number">0</span>]) / p) / F_(K[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_l2</span>(<span class="params">P</span>):</span><br><span class="line">            K = n0 * P</span><br><span class="line">            F_ = Zmod(p**<span class="number">20</span>)</span><br><span class="line">            <span class="keyword">return</span> F_(ZZ(K[<span class="number">0</span>]) / p**<span class="number">5</span>) / F_(K[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        d0 = ZZ(get_l(Q) / get_l(P))</span><br><span class="line"></span><br><span class="line">        P1 = p**<span class="number">4</span> * P</span><br><span class="line">        Q1 = Q - d0 * P</span><br><span class="line"></span><br><span class="line">        d1 = ZZ(get_l2(Q1) / get_l2(P1))</span><br><span class="line">        d_ = (d0 + p**<span class="number">4</span> * d1) % p**(l-<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Deal with lifting</span></span><br><span class="line">        <span class="keyword">if</span> d_ * P == Q:</span><br><span class="line">            d = d_</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            d = p**(l-<span class="number">1</span>) - d_</span><br><span class="line">        <span class="keyword">return</span> d</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recv_points</span>(<span class="params">self</span>):</span><br><span class="line">        self.P_list = []</span><br><span class="line">        self.conn.sendlineafter(<span class="string">&#x27;[Q]uit\n&#x27;</span>, <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.N):</span><br><span class="line">            self.P_list.append((i+<span class="number">1</span>, <span class="built_in">int</span>(self.conn.recvline().split(<span class="string">b&#x27;=&#x27;</span>)[<span class="number">1</span>])))</span><br><span class="line">        </span><br><span class="line">        self.Qx_list = []</span><br><span class="line">        self.conn.sendlineafter(<span class="string">&#x27;[Q]uit\n&#x27;</span>, <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.N):</span><br><span class="line">            self.Qx_list.append(<span class="built_in">int</span>(self.conn.recvline().split(<span class="string">b&#x27;=&#x27;</span>)[<span class="number">1</span>]))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gao_curve</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># N</span></span><br><span class="line">        gs = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.N - <span class="number">2</span>):</span><br><span class="line">            x1, y1 = self.P_list[i]</span><br><span class="line">            x2, y2 = self.P_list[i+<span class="number">1</span>]</span><br><span class="line">            x3, y3 = self.P_list[i+<span class="number">2</span>]</span><br><span class="line">            A1 = x1 - x2</span><br><span class="line">            B1 = (y1**<span class="number">2</span> - x1**<span class="number">3</span>) - (y2**<span class="number">2</span> - x2**<span class="number">3</span>)</span><br><span class="line">            A2 = x2 - x3</span><br><span class="line">            B2 = (y2**<span class="number">2</span> - x2**<span class="number">3</span>) - (y3**<span class="number">2</span> - x3**<span class="number">3</span>)</span><br><span class="line">            gs.append(A1 * B2 - A2 * B1)</span><br><span class="line">        g = gcd(gs)</span><br><span class="line">        fac = factor(g)</span><br><span class="line">        p, l = fac[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">assert</span> l == <span class="number">12</span></span><br><span class="line"></span><br><span class="line">        self.p, self.l = p, l</span><br><span class="line">        F = Zmod(p**l)</span><br><span class="line">        A = matrix(F, [[x1, <span class="number">1</span>],</span><br><span class="line">                       [x2, <span class="number">1</span>]])</span><br><span class="line">        B = vector(F, [y1**<span class="number">2</span> - x1**<span class="number">3</span>, y2**<span class="number">2</span> - x2**<span class="number">3</span>])</span><br><span class="line">        a, b = A.solve_right(B)</span><br><span class="line">        self.E = EllipticCurve(F, [a, b])</span><br><span class="line">        self.P_list = [self.E(P) <span class="keyword">for</span> P <span class="keyword">in</span> self.P_list]</span><br><span class="line">        self.Q_list = [self.E.lift_x(F(Qx)) <span class="keyword">for</span> Qx <span class="keyword">in</span> self.Qx_list]</span><br><span class="line">        self.E0 = self.E.change_ring(Zmod(p))</span><br><span class="line">        self.n0 = self.E0.order()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gao_dlp</span>(<span class="params">self</span>):</span><br><span class="line">        self.ds = [self.gao_dlp_one(P, Q) <span class="keyword">for</span> P, Q <span class="keyword">in</span> <span class="built_in">zip</span>(self.P_list, self.Q_list)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">submit_dlp</span>(<span class="params">self</span>):</span><br><span class="line">        self.conn.sendlineafter(<span class="string">&#x27;[Q]uit\n&#x27;</span>, <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> self.ds:</span><br><span class="line">            self.conn.sendlineafter(<span class="string">&#x27;integer:\n&#x27;</span>, <span class="built_in">str</span>(d))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gao</span>(<span class="params">self</span>):</span><br><span class="line">        self.recv_points()</span><br><span class="line">        self.gao_curve()</span><br><span class="line">        self.gao_dlp()</span><br><span class="line">        self.submit_dlp()</span><br><span class="line">        self.conn.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    g = Gao()</span><br><span class="line">    g.gao()</span><br></pre></td></tr></table></figure>
<h2 id="SingleRow-x"><a href="#SingleRow-x" class="headerlink" title="SingleRow (x)"></a>SingleRow (x)</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>记 $q = 256, k = 40, v = 64$。题目的运算都在 $\mathbb{F} = GF(q) = GF(2^8)$ 下进行。</p>
<p>首先生成公钥和私钥：</p>
<ol>
<li>记 $n = k + v$</li>
<li><code>makecore</code> 函数是往一个向量空间里面一直加入与其线性无关的向量，使得扩充之后的向量空间占据整个空间</li>
<li>用 <code>makecore</code> 生成一个满秩的矩阵 $M \in \mathbb{F}^{n \times n}$</li>
<li>生成 $k$ 个矩阵 $F_i, G_i$<br>a. 生成随机 $F_i \in \mathbb{F}^{n \times n}$，其中 $F_i$ 具有分块形式：<script type="math/tex; mode=display">F_i = \begin{bmatrix}A_i & B_i \\ C_i & D_i\end{bmatrix}</script>$A_i = 0^{k \times k}, B_i \in \mathbb{F}^{k \times v}, C_i \in \mathbb{F}^{v \times k}, D_i \in \mathbb{F}^{v \times v}$<br>b. <del>如果 $\mathbb{F}$ 的 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%89%B9%E5%BE%81_(%E4%BB%A3%E6%95%B0">特征</a>)不为 2，则更新 $F_i$ 的取值为 $F_i’ = 1/2 \cdot (F_i + F_i^\top)$</del>（因为 $\mathbb{F} = GF(2^8)$ 的特征总是 2，所以该条不会执行）<br>c. 计算 $G_i = M^\top F_i M$<br>d. 记录矩阵 $F_i$ 和 $G_i$</li>
<li>私钥为 $(M, F)$，公钥为 $G$，其中 $F$ 为若干个矩阵 $F_i$ 构成的列表，$G \in \mathbb{F}^k$ 为上述 $k$ 个 $G_i$ 构成的向量</li>
</ol>
<p>然后是一套签名的流程。假设我们有私钥 $(M, F)$ 和二进制消息 $G \in \{0, 1\}^{k}$：</p>
<ol>
<li>生成 $k$ 个变量 $x_{i}, i = 0, 1, \ldots, k-1$ 的，在 $\mathbb{F}$ 上定义的多项式环</li>
<li>生成向量 <script type="math/tex">Y = \begin{bmatrix}X \\ K \end{bmatrix} = \begin{bmatrix}x_0 \\ \vdots \\ x_{k-1} \\ ? \\ \vdots \\ ? \end{bmatrix} \in \mathbb{F}^{n}</script> 其中 $K$ 为 $Y$ 的问号部分，问号代表 $\mathbb{F}$ 中的随机元素</li>
<li>计算二次型 $E_i = Y^\top F_i Y$，并抽出 $E_i$ 中 $x_0, x_1, \ldots, x_{k-1}$ 的系数，构成一行 $S_i$；遍历所有的 $i$，可以构成一个 $k \times k$ 的矩阵 $S$</li>
<li>抽出上面二次型 $E_i$ 的常数部分，遍历所有的 $i$，可以构成一个向量，记为 $B \in \mathbb{F}^{n}$</li>
<li>计算 $T = G - B$</li>
<li>尝试解关于 $S’$ 的线性系统 $S S’ = T$；若能解出这样的 $S’$，则记 $V = \begin{bmatrix}S’ &amp; K\end{bmatrix}$</li>
<li>返回 $M^{-1} V$</li>
</ol>
<p>然后题目是一个 bit oracle：</p>
<ul>
<li>如果 <code>msg[i]</code> 是 0，那么返回 $M^{-1}$ 的前 $k$ 列向量张成空间中的随机一个元素</li>
<li>如果 <code>msg[i]</code> 是 1，那么返回对一个长为 $k$ 的随机消息签名的结果</li>
</ul>
<p>如果能根据 oracle 返回的结果，正确判定分支，那么就能拿到 flag。</p>
<h3 id="我的解答-x-2"><a href="#我的解答-x-2" class="headerlink" title="我的解答 (x)"></a>我的解答 (x)</h3><p>没看。</p>
<p>刚查了一下 1997 比赛时候的合作文档，好像没人去看这道题，寄。</p>
<p><em>注册的时候一卡车人，到后面就剩几个老登苦苦支撑</em></p>
<h3 id="赛后复盘-TODO"><a href="#赛后复盘-TODO" class="headerlink" title="赛后复盘 (TODO)"></a>赛后复盘 (TODO)</h3><p>注意到上面虽然说是说了公钥和私钥，但是 <strong>公钥也是未知的……</strong></p>
<p>而且光是将题目代码转述成上面文字描述，都看起来好长一坨</p>
<p>然后注意到可以用 flag 格式 <code>CCTF&#123;&#125;</code> 得知部分 oracle 结果的正确答案（已知信息）：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">flag_format = <span class="string">b&quot;CCTF&#123;&#125;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;bytes_to_long(flag_format) = :b&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;bytes_to_long(flag_format).bit_count()&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>也就是有 24 组结果我们是知道的</p>
<p>先尝试写开一些东西，把 $M$ 写成分块矩阵</p>
<script type="math/tex; mode=display">M = \begin{bmatrix}M_1 \\ M_2\end{bmatrix}</script><p>其中 $M_1 \in \mathbb{F}^{k \times n}, M_2 \in \mathbb{F}^{v \times n}$</p>
<p>然后密钥生成中的 $G_i$ 写开了就是</p>
<script type="math/tex; mode=display">\begin{aligned}G_i &= M^\top F_i M \\
&= \begin{bmatrix}M_1^\top & M_2^\top\end{bmatrix} \begin{bmatrix}0 & B_i \\ C_i & D_i\end{bmatrix} \begin{bmatrix}M_1 \\ M_2\end{bmatrix} \\
&= \begin{bmatrix}M_2^\top C_i & M_1^\top B_i + M_2^\top D_i \end{bmatrix} \begin{bmatrix}M_1 \\ M_2\end{bmatrix} \\
&= M_2^\top C_i M_1 +M_1^\top B_i M_2 + M_2^\top D_i M_2\end{aligned}</script><p>然后签名中的 $E_i$ 写开了就是</p>
<script type="math/tex; mode=display">\begin{aligned}E_i &= Y^\top F_i Y \\
&= \ldots \\
&= K^\top C_i X +X^\top B_i K + K^\top D_i K\end{aligned}</script><p>所以 $B$ 的第 $i$ 个分量 $B_i = K^\top D_i K$，$T$ 的第 $i$ 个分量 $T_i = G_i - B_i$</p>
<p>然后就是 $S$ 矩阵，因为 $S$ 矩阵的第 $i$ 行 $S_i$ 是把 $x_i$ 的系数拼起来的，所以 $S_i = K^\top (C_i + B_i^\top)$</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://zm-j.github.io">ZM-J</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://zm-j.github.io/2025/09/30/cryptoctf-2025-head-scratcher/">https://zm-j.github.io/2025/09/30/cryptoctf-2025-head-scratcher/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2025/09/09/cryptoctf-2025-brain-buster/" title="CryptoCTF 2025 brain buster 分类 团队解题 writeup"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">CryptoCTF 2025 brain buster 分类 团队解题 writeup</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ZM-J</div><div class="author-info__description">丧失年轻，勿失年华</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ZM-J"><i class="fab fa-github"></i><span>信春哥</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://www.zhihu.com/people/ZM_________J" target="_blank" title="Zhihu"><i class="fab fa-zhihu" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">春哥纯爷们，铁血真汉子。人民好兄弟，父亲好儿子。拳上能站人，臂上能走马！夜御十女枪不倒，菊花百战色仍红！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Alice-Sig-Slip-x"><span class="toc-number">1.</span> <span class="toc-text">Alice Sig Slip (x)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%91%E7%9A%84%E8%A7%A3%E7%AD%94-x"><span class="toc-number">1.2.</span> <span class="toc-text">我的解答 (x)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%9B%E5%90%8E%E5%A4%8D%E7%9B%98"><span class="toc-number">1.3.</span> <span class="toc-text">赛后复盘</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hoshi-x"><span class="toc-number">2.</span> <span class="toc-text">Hoshi (x)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><span class="toc-number">2.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%91%E7%9A%84%E8%A7%A3%E7%AD%94-x-1"><span class="toc-number">2.2.</span> <span class="toc-text">我的解答 (x)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%9B%E5%90%8E%E5%A4%8D%E7%9B%98-1"><span class="toc-number">2.3.</span> <span class="toc-text">赛后复盘</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SingleRow-x"><span class="toc-number">3.</span> <span class="toc-text">SingleRow (x)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="toc-number">3.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%91%E7%9A%84%E8%A7%A3%E7%AD%94-x-2"><span class="toc-number">3.2.</span> <span class="toc-text">我的解答 (x)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%9B%E5%90%8E%E5%A4%8D%E7%9B%98-TODO"><span class="toc-number">3.3.</span> <span class="toc-text">赛后复盘 (TODO)</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/30/cryptoctf-2025-head-scratcher/" title="CryptoCTF 2025 head scratcher 分类 团队解题 writeup">CryptoCTF 2025 head scratcher 分类 团队解题 writeup</a><time datetime="2025-09-30T10:14:00.000Z" title="Created 2025-09-30 18:14:00">2025-09-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/09/cryptoctf-2025-brain-buster/" title="CryptoCTF 2025 brain buster 分类 团队解题 writeup">CryptoCTF 2025 brain buster 分类 团队解题 writeup</a><time datetime="2025-09-09T07:04:00.000Z" title="Created 2025-09-09 15:04:00">2025-09-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/02/cryptoctf-2025-tough-cookie-3/" title="CryptoCTF 2025 tough cookie 分类 团队解题 writeup 之三">CryptoCTF 2025 tough cookie 分类 团队解题 writeup 之三</a><time datetime="2025-09-02T09:28:00.000Z" title="Created 2025-09-02 17:28:00">2025-09-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/13/cryptoctf-2025-tough-cookie-2/" title="CryptoCTF 2025 tough cookie 分类 团队解题 writeup 之二">CryptoCTF 2025 tough cookie 分类 团队解题 writeup 之二</a><time datetime="2025-08-13T09:52:00.000Z" title="Created 2025-08-13 17:52:00">2025-08-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/04/cryptoctf-2025-tough-cookie-1/" title="CryptoCTF 2025 tough cookie 分类 团队解题 writeup 之一">CryptoCTF 2025 tough cookie 分类 团队解题 writeup 之一</a><time datetime="2025-08-04T03:54:00.000Z" title="Created 2025-08-04 11:54:00">2025-08-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By ZM-J</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="Chat"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: 'Ov23lib8keprJGNom7Yt',
      clientSecret: 'ec292b94fcfc3c36860e77622a4a4b37639c983a',
      repo: 'ZM-J.github.io',
      owner: 'ZM-J',
      admin: ['ZM-J'],
      id: '5a0a37f776f3e270b43d981402d18542',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.css')
      await getScript('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>